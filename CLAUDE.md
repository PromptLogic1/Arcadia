# CLAUDE.md

This file provides guidance to AI assistants (like you!) when working with code in this repository. Please consult this document thoroughly before generating code, making architectural decisions, or if you need context on development practices.

## Important Notes for AI Assistants

- **Adherence to Rules**: Strictly follow all project rules, including those provided in your initial prompts (e.g., concerning type safety, Shadcn/ui usage, incremental feature implementation) and the guidelines within this document.
- **Database Type Generation**: After any database schema migration is created or applied, ensure TypeScript types are regenerated by running `npm run db:types`. Use the updated types from `types/database.ts` (or similarly named files in the `types/` directory) for all database interactions.
- **Ask for Clarification**: If any instruction is ambiguous or seems to conflict with established patterns or rules, please ask for clarification before proceeding.
- **Incremental Implementation**: For new features, remember the "Prove it Small, Scale it Right" principle. Implement in a minimal scope first, validate, and then propagate.
- **Address Warnings**: Take linter and type-checker warnings seriously and address them.

## Essential Commands

### Development

```bash
npm run dev           # Start development server
npm run dev:turbo     # Start with Turbo mode (faster)
npm run build         # Production build
npm run start         # Start production server
```

### Code Quality

```bash
npm run lint          # Run ESLint
npm run lint:fix      # Auto-fix ESLint issues
npm run type-check    # TypeScript type checking
npm run format        # Format with Prettier
npm run validate      # Run all checks (type-check + lint + format)
```

### Testing

```bash
npm test              # Run all tests
npm run test:watch    # Watch mode
npm run test:coverage # Coverage report
jest path/to/test     # Run specific test file (e.g., jest src/features/auth/__tests__/Login.test.ts)
```

### Database & Migrations

```bash
npm run db:start      # Start local Supabase
npm run db:types      # Generate TypeScript types from local DB (Run this after schema changes)
npm run db:reset      # Reset database
npm run migration:new <migration_name_in_snake_case> # Create new migration
npm run migration:validate # Validate migrations
```

## Architecture Overview

### Core Stack

- **Next.js 15** with App Router and Edge Runtime
- **TypeScript** with strict type safety (goal: no `any` types)
- **Supabase** for database, auth, and real-time features
- **Zustand** for state management
- **Tailwind CSS v4** for styling
- **Shadcn/ui** for UI components (use for basic components; check `components.json`)
- **React Hook Form + Zod** for forms and validation

### Project Structure

```
src/
├── app/              # Next.js App Router pages
├── features/         # Feature-based modules (main business logic)
│   ├── auth/        # Authentication
│   ├── bingo-boards/# Core gaming feature
│   ├── community/   # Social features
│   └── ...
├── components/      # Shared UI components (often built with Shadcn/ui)
├── lib/            # Core utilities
│   ├── stores/     # Zustand global stores
│   └── supabase.ts # Database client
├── hooks/          # Shared React hooks
└── types/          # Global TypeScript types

types/              # Database types (e.g., database.ts, auto-generated by `npm run db:types`)
```

### Key Architectural Patterns

1. **Feature-Based Organization**: Each feature in `src/features/` is self-contained with its own components, hooks, types, and services.

2. **Type-Safe Database Access**:

   - Database types are generated from Supabase schema using `npm run db:types`.
   - All database operations must be fully typed using these generated types.
   - Generated types are typically located in `/types/database.ts` or similar. **Always regenerate and use these after schema changes.**

3. **State Management Flow**:

   ```
   Supabase → Service Layer (typed) → Zustand Store (typed) → Custom Hook (typed) → Component (typed)
   ```

4. **Server Components by Default**: Components are server-side unless explicitly marked with `'use client'`.

5. **Edge-First Architecture**: Middleware runs at the edge for auth and routing.

### Development Guidelines

1. **Data Contracts First**: Define types (e.g., using Zod for validation, TypeScript for interfaces/types) for data structures and API request/response shapes _before_ implementing backend logic or consuming it in the frontend. (See Cursor rules).

2. **Keep Effects Pure**: Isolate side effects (e.g., API calls, local storage, routing) in dedicated service modules, React `useEffect` hooks, or event handlers. Pure functions should form the core of your logic where possible.

3. **Prove it Small, Scale it Right**: Implement and validate new features or patterns in a minimal, isolated scope first. Once proven correct and adhering to best practices, then consider generalizing and applying them more broadly.

4. **Ultimate Type Safety**: Leverage TypeScript's type system extensively. **Avoid `any` types vigorously.** Strive for comprehensive type coverage.

5. **Feature Isolation**: Keep feature-specific code (components, hooks, services, types) within its respective feature directory (e.g., `src/features/feature-name/`) to maintain clear boundaries and modularity.

6. **UI with Shadcn/ui**: Utilize **Shadcn/ui** for building UI components, especially for common elements. Refer to `components.json` for local configuration and ensure consistency with existing UI patterns.

7. **Handle Warnings**: Treat warnings from ESLint, TypeScript, and other tools as errors to be fixed. Do not ignore them.

### Common Patterns

- **Custom Hooks**: Encapsulate business logic, state access (via Zustand selectors), and complex UI logic within custom hooks. These hooks should also be well-typed.
- **Service Layer**: Place complex business logic, especially logic involving external interactions (like Supabase calls), in `services/` files within each feature module.
- **Error Boundaries**: Implement error boundaries at appropriate levels (e.g., per feature or major component group) to enhance application resilience.
- **Optimistic Updates**: For real-time features, consider using optimistic updates to improve perceived performance, ensuring proper state reconciliation.
- **Virtual Scrolling**: For rendering large lists or tables, use solutions like Tanstack Virtual to maintain performance.

### Testing Approach

- Jest + React Testing Library for unit and integration tests.
- Tests are co-located with the code they test, typically in `__tests__` directories.
- Mock the Supabase client (`src/lib/supabase.ts`) and other external services for isolated testing of components and logic.
- **Focus on user interactions and behavior over testing internal implementation details.** Ensure components are accessible and function as a user would expect.
