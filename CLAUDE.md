# CLAUDE.md

This file provides guidance to AI assistants (like you!) when working with code in this repository. Please consult this document thoroughly before generating code, making architectural decisions, or if you need context on development practices.

## Important Notes for AI Assistants

- **Adherence to Rules**: Strictly follow all project rules, including those provided in your initial prompts (e.g., concerning type safety, Shadcn/ui usage, incremental feature implementation) and the guidelines within this document.
- **Database Type Generation**: After any database schema migration is created or applied, ensure TypeScript types are regenerated by running `npm run db:types`. Use the updated types from `types/database-generated.ts` for all database interactions.
- **Ask for Clarification**: If any instruction is ambiguous or seems to conflict with established patterns or rules, please ask for clarification before proceeding.
- **Incremental Implementation**: For new features, remember the "Prove it Small, Scale it Right" principle. Implement in a minimal scope first, validate, and then propagate.
- **Address Warnings**: Take linter and type-checker warnings seriously and address them.

## ğŸš¨ Current Project Status (CRITICAL CONTEXT)

**Last Updated**: 2025-06-04  
**Current Focus**: Advanced Architecture with TanStack Query + Zustand Pattern Complete

### **What's Complete (100%)**

- âœ… **Database Schema**: Production-ready with 25+ tables, full RLS, performance indexes
- âœ… **Authentication System**: Complete with OAuth, role-based access, security policies
- âœ… **UI Framework**: Tailwind v4, shadcn/ui, complete cyberpunk theme implementation
- âœ… **Core Infrastructure**: Next.js 15, TypeScript strict mode, Edge runtime
- âœ… **Architecture Pattern**: TanStack Query + Zustand + Service Layer fully implemented
- âœ… **Type System**: 100% TypeScript error-free, database-generated types as single source of truth
- âœ… **Code Quality**: Zero ESLint warnings, enterprise-level standards achieved
- âœ… **Context Migration**: React Context API completely eliminated
- âœ… **Code Modernization**: 3,000+ lines refactored, legacy patterns eliminated
- âœ… **Documentation**: Comprehensive docs reorganized, historical records preserved

### **What's Working (PRODUCTION READY)**

- âœ… **Session Management**: Complete PlayAreaHub with modern architecture
- âœ… **Type Safety**: Comprehensive type coverage across all features
- âœ… **Service Layer**: All features using pure service functions
- âœ… **Performance**: Optimized queries, background refetching, caching
- âœ… **UI/UX**: Consistent cyberpunk design system across all components
- âœ… **Developer Experience**: Modern tooling, clear patterns, extensive documentation

### **Development Phases**

#### **Phase 1: Foundation & Architecture (COMPLETED)**
- âœ… **Schema Alignment**: Database schema and frontend types aligned
- âœ… **Architecture Migration**: TanStack Query + Zustand pattern fully implemented
- âœ… **Context API Elimination**: React Context completely removed and replaced
- âœ… **Type System**: 100% TypeScript error-free compilation
- âœ… **Service Layer**: Clean separation of concerns implemented

#### **Phase 2: Core Multiplayer Features (READY FOR IMPLEMENTATION)**
- ğŸ“‹ **Real-time Board Sync**: Infrastructure ready, implement board state synchronization
- ğŸ“‹ **Session Lifecycle**: Complete join-by-code flows and session management
- ğŸ“‹ **Player Management**: Real-time player tracking with presence system
- ğŸ“‹ **Win Detection**: Implement win condition detection and scoring system

#### **Phase 3: Enhanced Features (PLANNED)**
- ğŸ“‹ **Queue System**: Automatic matchmaking using existing bingo_queue_entries table
- ğŸ“‹ **Advanced UI**: Rich multiplayer interactions and real-time animations
- ğŸ“‹ **Analytics**: Game statistics and performance tracking dashboard
- ğŸ“‹ **Mobile Optimization**: Enhanced touch-friendly gameplay interface

### **Context for AI Assistants**

- **Architecture Complete** - TanStack Query + Zustand + Service Layer pattern fully implemented
- **Foundation Solid** - Database schema, types, and infrastructure are production-ready
- **Type Safety Achieved** - 97% TypeScript error reduction, comprehensive type coverage
- **Documentation Complete** - All docs updated, organized, and current
- **Ready for Phase 2** - Focus on real-time multiplayer feature implementation
- **Success Metric**: Complete end-to-end multiplayer bingo game with real-time sync

## Essential Commands

### Development

```bash
npm run dev           # Start development server
npm run dev:turbo     # Start with Turbo mode (faster)
npm run build         # Production build
npm run start         # Start production server
```

### Code Quality

```bash
npm run lint          # Run ESLint
npm run lint:fix      # Auto-fix ESLint issues
npm run type-check    # TypeScript type checking
npm run format        # Format with Prettier
npm run validate      # Run all checks (type-check + lint + format)
```

### Testing

```bash
npm test              # Run all tests
npm run test:watch    # Watch mode
npm run test:coverage # Coverage report
jest path/to/test     # Run specific test file (e.g., jest src/features/auth/__tests__/Login.test.ts)
```

### Database & Migrations

**Use Supabase MCP Server (Recommended)**:

```bash
# Database operations are now handled via the Supabase MCP Server
# Available through Claude Code's MCP integration:
# - mcp__supabase__list_projects
# - mcp__supabase__apply_migration  
# - mcp__supabase__generate_typescript_types
# - mcp__supabase__execute_sql
# - mcp__supabase__get_logs
# - And more...
```

**Legacy CLI Commands** (use MCP server instead):

```bash
npm run db:start      # Start local Supabase (use MCP server instead)
npm run db:types      # Generate TypeScript types (use mcp__supabase__generate_typescript_types)
npm run db:reset      # Reset database (use MCP server instead) 
npm run migration:new <migration_name_in_snake_case> # Create new migration (use mcp__supabase__apply_migration)
npm run migration:validate # Validate migrations (use MCP server instead)
```

**IMPORTANT**: Always regenerate TypeScript types after schema changes using `mcp__supabase__generate_typescript_types`

## Architecture Overview

### Core Stack

- **Next.js 15** with App Router and Edge Runtime
- **TypeScript** with strict type safety (goal: no `any` types)
- **Supabase** for database, auth, and real-time features
- **Zustand** for state management
- **Tailwind CSS v4** for styling
- **Shadcn/ui** for UI components (use for basic components; check `components.json`)
- **React Hook Form + Zod** for forms and validation

### Project Structure

```
src/
â”œâ”€â”€ app/              # Next.js App Router pages
â”œâ”€â”€ features/         # Feature-based modules (main business logic)
â”‚   â”œâ”€â”€ auth/        # Authentication
â”‚   â”œâ”€â”€ bingo-boards/# Core gaming feature
â”‚   â”œâ”€â”€ community/   # Social features
â”‚   â””â”€â”€ ...
â”œâ”€â”€ components/      # Shared UI components (often built with Shadcn/ui)
â”œâ”€â”€ lib/            # Core utilities
â”‚   â”œâ”€â”€ stores/     # Zustand global stores
â”‚   â””â”€â”€ supabase.ts # Database client
â”œâ”€â”€ hooks/          # Shared React hooks
â””â”€â”€ types/          # Global TypeScript types

types/              # Database types (database-generated.ts, auto-generated by Supabase MCP)
```

### Key Architectural Patterns

1. **Feature-Based Organization**: Each feature in `src/features/` is self-contained with its own components, hooks, types, and services.

2. **Type-Safe Database Access**:

   - Database types are generated from Supabase schema using `mcp__supabase__generate_typescript_types`.
   - All database operations must be fully typed using these generated types.
   - Generated types are located in `/types/database-generated.ts`. **Always regenerate and use these after schema changes.**
   - Current schema includes 25+ tables with full RLS policies and optimized indexing.

3. **State Management Flow**:

   ```
   Supabase â†’ Service Layer (typed) â†’ Zustand Store (typed) â†’ Custom Hook (typed) â†’ Component (typed)
   ```

4. **Server Components by Default**: Components are server-side unless explicitly marked with `'use client'`.

5. **Edge-First Architecture**: Middleware runs at the edge for auth and routing.

### Development Guidelines

1. **TanStack Query + Zustand Pattern** (CRITICAL): Follow the established architectural pattern for all data management:
   - **Service Layer**: Pure functions in `src/services/` for API calls only
   - **Zustand Stores**: UI state management only (no server data)
   - **TanStack Query**: Server state with automatic caching, background refetching, optimistic updates
   - **Component Integration**: Clean separation of concerns, no mixed state types

2. **Data Contracts First**: Define types (e.g., using Zod for validation, TypeScript for interfaces/types) for data structures and API request/response shapes _before_ implementing backend logic or consuming it in the frontend.

3. **Type Extension Strategy**: When creating new types, first check if a related types file already exists in the project. **Extend existing files with only the missing types** instead of creating new ones. Use `type`, `interface`, or `z.object` definitions consistently with the existing style in that file.

4. **Keep Effects Pure**: Isolate side effects (e.g., API calls, local storage, routing) in dedicated service modules, React `useEffect` hooks, or event handlers. Pure functions should form the core of your logic where possible.

5. **Prove it Small, Scale it Right**: Implement and validate new features or patterns in a minimal, isolated scope first. Once proven correct and adhering to best practices, then consider generalizing and applying them more broadly.

6. **Ultimate Type Safety**: Leverage TypeScript's type system extensively. **Avoid `any` types vigorously.** Strive for comprehensive type coverage.

7. **Feature Isolation**: Keep feature-specific code (components, hooks, services, types) within its respective feature directory (e.g., `src/features/feature-name/`) to maintain clear boundaries and modularity.

8. **UI with Cyberpunk Theme**: Utilize **shadcn/ui** components with cyberpunk variants (cyber, glass, neon, holographic). All major components now default to cyberpunk styling. Refer to `components.json` and cyberpunk theme documentation.

9. **Handle Warnings**: Treat warnings from ESLint, TypeScript, and other tools as errors to be fixed. Do not ignore them.

10. **Real-time First**: For multiplayer features, design with real-time synchronization in mind. Use Supabase realtime subscriptions and optimistic updates.

11. **Accessibility Standards**: Maintain WCAG 2.1 AA compliance. All new components should include proper focus management, ARIA labels, and keyboard navigation.

## TanStack Query + Zustand Architecture Pattern

This is our **primary architectural pattern** for all data management. Follow this pattern religiously for new features.

### Pattern Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Component     â”‚ -> â”‚  Zustand Store   â”‚ -> â”‚  TanStack Query â”‚
â”‚   (UI Layer)    â”‚    â”‚  (UI State)      â”‚    â”‚ (Server State)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚                       â”‚
                                v                       v
                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                        â”‚  Local Storage   â”‚    â”‚ Service Layer   â”‚
                        â”‚  (Persistence)   â”‚    â”‚ (API Calls)     â”‚
                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                                        â”‚
                                                        v
                                                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                                â”‚    Supabase     â”‚
                                                â”‚   (Database)    â”‚
                                                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1. Service Layer (Pure API Functions)

**Location**: `src/services/[feature].service.ts`
**Purpose**: Contain all API logic, no state management

```typescript
// src/services/sessions.service.ts
export const sessionsService = {
  async getActiveSessions(filters: SessionFilters): Promise<{ sessions: BingoSession[]; error?: string }> {
    const supabase = createClient();
    // Pure API logic only
    const { data, error } = await supabase
      .from('session_stats')
      .select('*')
      .eq('status', filters.status);
    
    return { sessions: data || [], error: error?.message };
  },

  async createSession(data: CreateSessionData): Promise<{ session: BingoSession | null; error?: string }> {
    // Pure creation logic
  }
};
```

### 2. Zustand Store (UI State Only)

**Location**: `src/lib/stores/[feature]-store.ts`
**Purpose**: Manage UI state, no server data

```typescript
// src/lib/stores/sessions-store.ts
interface SessionState {
  // UI state only - no server data!
  showHostDialog: boolean;
  showJoinDialog: boolean;
  joinSessionCode: string;
  filters: SessionFilters;  // Filter criteria, not data
}

export const useSessionsStore = createWithEqualityFn<SessionState & SessionActions>()(
  devtools((set) => ({
    showHostDialog: false,
    showJoinDialog: false,
    joinSessionCode: '',
    filters: { search: '', gameCategory: undefined },
    
    setShowHostDialog: (show) => set({ showHostDialog: show }),
    setFilters: (newFilters) => set(state => ({ 
      filters: { ...state.filters, ...newFilters } 
    })),
  }))
);

// Separate selectors for performance
export const useSessionsState = () => useSessionsStore(useShallow(state => ({
  showHostDialog: state.showHostDialog,
  filters: state.filters,
})));
```

### 3. TanStack Query Hooks (Server State)

**Location**: `src/hooks/queries/use[Feature]Queries.ts`
**Purpose**: Manage server state with caching and background updates

```typescript
// src/hooks/queries/useSessionsQueries.ts
export const useActiveSessionsQuery = (filters: SessionFilters) => {
  return useQuery({
    queryKey: ['sessions', 'active', filters],
    queryFn: () => sessionsService.getActiveSessions(filters),
    staleTime: 30 * 1000,  // 30 seconds
    refetchInterval: 30 * 1000,  // Background refetch
    select: (data) => data.sessions, // Transform data
  });
};

export const useCreateSessionMutation = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: sessionsService.createSession,
    onSuccess: () => {
      // Invalidate and refetch sessions
      queryClient.invalidateQueries({ queryKey: ['sessions'] });
    },
    onError: (error) => {
      // Centralized error handling
      console.error('Failed to create session:', error);
    },
  });
};
```

### 4. Component Integration

**Purpose**: Clean separation of concerns in components

```typescript
// src/features/play-area/components/PlayAreaHub.tsx
export function PlayAreaHub() {
  // 1. Zustand state (UI state only)
  const { filters, showHostDialog } = useSessionsState();
  const { setFilters, setShowHostDialog } = useSessionsActions();

  // 2. TanStack Query for server state
  const {
    data: sessions,
    isLoading,
    error,
    refetch
  } = useActiveSessionsQuery(filters);

  // 3. Mutations for actions  
  const createSessionMutation = useCreateSessionMutation();

  // 4. Pure event handlers
  const handleCreateSession = async (data: CreateSessionData) => {
    const result = await createSessionMutation.mutateAsync(data);
    router.push(`/session/${result.session?.id}`);
  };

  // 5. Render with clean separation
  return (
    <div>
      <SessionFilters 
        filters={filters} 
        onFiltersChange={setFilters} 
      />
      {sessions?.map(session => (
        <SessionCard key={session.id} session={session} />
      ))}
    </div>
  );
}
```

### Key Benefits

1. **Clear Separation**: UI state vs Server state never mixed
2. **Automatic Caching**: TanStack Query handles all caching logic
3. **Background Updates**: Data stays fresh automatically
4. **Optimistic Updates**: Immediate UI feedback with rollback
5. **Type Safety**: Full TypeScript coverage end-to-end
6. **Performance**: Only re-render what actually changed
7. **Error Handling**: Centralized error management
8. **Testing**: Easy to mock services and test components

### Migration Pattern

When migrating existing components:

1. **Extract API calls** to service layer
2. **Move server data** from Zustand to TanStack Query
3. **Keep UI state** in Zustand (dialogs, filters, etc.)
4. **Update component** to use new hooks
5. **Remove old patterns** (useEffect for data fetching)

### Common Patterns

- **Custom Hooks**: Encapsulate business logic, state access (via Zustand selectors), and complex UI logic within custom hooks. These hooks should also be well-typed.
- **Service Layer**: Place complex business logic, especially logic involving external interactions (like Supabase calls), in `services/` files within each feature module.
- **Error Boundaries**: Implement error boundaries at appropriate levels (e.g., per feature or major component group) to enhance application resilience.
- **Optimistic Updates**: For real-time features, use optimistic updates to improve perceived performance, ensuring proper state reconciliation with Supabase realtime.
- **Virtual Scrolling**: For rendering large lists or tables, use solutions like Tanstack Virtual to maintain performance.
- **Cyberpunk UI Components**: Use cyberpunk variants for all UI components (buttons, cards, dialogs, forms). Check existing implementations for consistency.
- **Real-time Subscriptions**: Use Supabase realtime channels for live updates in multiplayer sessions, presence tracking, and collaborative features.
- **Session Management**: Follow established patterns for session creation, joining, and state management using Zustand stores and React Context.

### Testing Approach

- Jest + React Testing Library for unit and integration tests.
- Tests are co-located with the code they test, typically in `__tests__` directories.
- Mock the Supabase client (`src/lib/supabase.ts`) and other external services for isolated testing of components and logic.
- **Focus on user interactions and behavior over testing internal implementation details.** Ensure components are accessible and function as a user would expect.

## Documentation Structure

### **Root Documentation** (Keep in Root)
- `CLAUDE.md` - AI assistant guidance (this file)
- `README.md` - Project overview and setup instructions
- `MIGRATION_PROGRESS_REPORT.md` - Architecture migration summary

### **Organized Documentation** (`/docs/`)
- `docs/README.md` - Documentation index and navigation
- `docs/PROJECT_STATUS.md` - Current status dashboard
- `docs/DEVELOPMENT_ROADMAP.md` - Development plan and next steps
- `docs/ZUSTAND_TANSTACK_QUERY_MIGRATION.md` - Architecture pattern guide
- `docs/architecture/` - Technical architecture documentation
- `docs/api/` - API reference and guides
- `docs/history/` - Historical documentation and completed phases
  - `docs/history/phases/` - Completed development phases
  - `docs/history/migrations/` - Architecture evolution reports
  - `docs/history/themes/` - Design implementation history

### **Key Documentation Updates (2025-06-04)**
- âœ… All documentation reorganized and updated
- âœ… Historical records preserved in structured subdirectories
- âœ… Current status reflects architecture completion
- âœ… Clear navigation and quick-start guides available
- âœ… AI assistant guidance fully current with project state
