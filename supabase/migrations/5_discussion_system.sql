-- Community System Tables
CREATE TABLE discussions (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    title TEXT NOT NULL,
    content TEXT NOT NULL,
    game TEXT NOT NULL,
    challenge_type TEXT,
    tags TEXT[] DEFAULT '{}',
    upvotes INTEGER DEFAULT 0 NOT NULL,
    comment_count INTEGER DEFAULT 0 NOT NULL,
    author_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    CONSTRAINT title_length CHECK (char_length(title) >= 3),
    CONSTRAINT content_length CHECK (char_length(content) >= 10)
);

CREATE TABLE comments (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    content TEXT NOT NULL,
    upvotes INTEGER DEFAULT 0 NOT NULL,
    author_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    discussion_id BIGINT NOT NULL REFERENCES discussions(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    CONSTRAINT content_length CHECK (char_length(content) >= 1)
);

-- RPC Functions with improved error handling
CREATE OR REPLACE FUNCTION increment_discussion_upvotes(discussion_id BIGINT)
RETURNS void AS $$
BEGIN
    UPDATE discussions
    SET 
        upvotes = upvotes + 1,
        updated_at = NOW()
    WHERE id = discussion_id;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Discussion with ID % not found', discussion_id;
    END IF;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION add_comment(
    p_discussion_id BIGINT,
    p_content TEXT,
    p_author_id UUID
)
RETURNS comments AS $$
DECLARE
    new_comment comments;
BEGIN
    -- Validate inputs
    IF p_content IS NULL OR length(trim(p_content)) = 0 THEN
        RAISE EXCEPTION 'Comment content cannot be empty';
    END IF;

    -- Insert the comment
    INSERT INTO comments (discussion_id, content, author_id)
    VALUES (p_discussion_id, p_content, p_author_id)
    RETURNING * INTO new_comment;

    -- Update the comment count
    UPDATE discussions
    SET 
        comment_count = comment_count + 1,
        updated_at = NOW()
    WHERE id = p_discussion_id;

    IF NOT FOUND THEN
        -- Rollback comment insertion if discussion not found
        DELETE FROM comments WHERE id = new_comment.id;
        RAISE EXCEPTION 'Discussion with ID % not found', p_discussion_id;
    END IF;

    RETURN new_comment;
EXCEPTION
    WHEN foreign_key_violation THEN
        RAISE EXCEPTION 'Invalid discussion ID or author ID';
END;
$$ LANGUAGE plpgsql;

-- Indices for better query performance
CREATE INDEX IF NOT EXISTS idx_discussions_author_id ON discussions(author_id);
CREATE INDEX IF NOT EXISTS idx_discussions_game ON discussions(game);
CREATE INDEX IF NOT EXISTS idx_discussions_created_at ON discussions(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_discussions_upvotes ON discussions(upvotes DESC);
CREATE INDEX IF NOT EXISTS idx_comments_discussion_id ON comments(discussion_id);
CREATE INDEX IF NOT EXISTS idx_comments_author_id ON comments(author_id);
CREATE INDEX IF NOT EXISTS idx_comments_created_at ON comments(created_at DESC);

-- Full text search index
CREATE INDEX IF NOT EXISTS idx_discussions_fts ON discussions USING GIN (
    to_tsvector('english', title || ' ' || content)
);

-- RLS Policies
ALTER TABLE discussions ENABLE ROW LEVEL SECURITY;
ALTER TABLE comments ENABLE ROW LEVEL SECURITY;

-- Everyone can read discussions and comments
CREATE POLICY "Discussions are viewable by everyone" 
    ON discussions FOR SELECT USING (true);

CREATE POLICY "Comments are viewable by everyone" 
    ON comments FOR SELECT USING (true);

-- Only authenticated users can create discussions and comments
CREATE POLICY "Authenticated users can create discussions" 
    ON discussions FOR INSERT 
    WITH CHECK (auth.uid() = author_id);

CREATE POLICY "Authenticated users can create comments" 
    ON comments FOR INSERT 
    WITH CHECK (auth.uid() = author_id);

-- Users can only update their own discussions and comments
CREATE POLICY "Users can update own discussions" 
    ON discussions FOR UPDATE 
    USING (auth.uid() = author_id);

CREATE POLICY "Users can update own comments" 
    ON comments FOR UPDATE 
    USING (auth.uid() = author_id);

-- Users can only delete their own discussions and comments
CREATE POLICY "Users can delete own discussions" 
    ON discussions FOR DELETE 
    USING (auth.uid() = author_id);

CREATE POLICY "Users can delete own comments" 
    ON comments FOR DELETE 
    USING (auth.uid() = author_id);

-- Notify triggers for real-time updates
CREATE OR REPLACE FUNCTION notify_discussion_change()
RETURNS TRIGGER AS $$
BEGIN
    PERFORM pg_notify(
        'discussion_change',
        json_build_object(
            'operation', TG_OP,
            'record', row_to_json(NEW)
        )::text
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER notify_discussion_change
    AFTER INSERT OR UPDATE OR DELETE ON discussions
    FOR EACH ROW
    EXECUTE FUNCTION notify_discussion_change(); 